#include "system.hpp"

#include "exceptions.hpp"
#include "log.hpp"
#include <cstdarg>
#include <cstdio>
#include <cstdlib>
#include <sys/types.h>
#include <sys/wait.h>
#include <dirent.h>
#include <fstream>
#include <cerrno>
#include <unistd.h>

#include <boost/algorithm/string.hpp>
#include "configurations.hpp"
#include "math.hpp"

namespace cpp_utils {

	namespace internal {

		::std::string callPyEval(::std::stringstream& ss) {
            return ss.str();
        }

		struct pid {
			struct pid *next;
			FILE *fp;
			pid_t pid;
		};

		/**
		 * @brief list of all the pids generated by using custom popenRead method
		 * 
		 */
		static struct pid* pidlist = nullptr;

	}

	size_t getPIDNumberOpened() {
		size_t result = 0;
		for (internal::pid* cur = internal::pidlist; cur != nullptr; cur = cur->next) {
			result += 1;
		}
		return result;
	}

	int pclose(FILE* fileDescriptor) {
		int pstat;
		pid_t pid;

		/* Find the appropriate file pointer. */
		internal::pid* last = nullptr;
		internal::pid* cur = nullptr;
		for (cur = internal::pidlist; cur != nullptr; last = cur, cur = cur->next) {
			if (cur->fp == fileDescriptor) {
				break;
			}
		}
		if (cur == nullptr) {
			//cursor not found
			return (-1);
		}

		(void)fclose(fileDescriptor);
		do {
			pid = waitpid(cur->pid, &pstat, 0);
		} while (pid == -1 && errno == EINTR);

		/* Remove the entry from the linked list. */
		if (last == nullptr) {
			internal::pidlist = cur->next;
		} else {
			last->next = cur->next;
		}
		delete cur;
		return (pid == -1 ? -1 : pstat);
	}

	/**
	 * @brief a custom implementation of popn command
	 * 
	 * @note this implementation have been taken from internet
	 * 
	 * @param command 
	 * @return FILE* 
	 * @see https://stackoverflow.com/questions/31033705/why-is-popen-failing-with-cannot-allocate-memory
	 * @see https://stackoverflow.com/questions/19667243/c-pipe-without-using-popen
	 * @see https://android.googlesource.com/platform/bionic/+/3884bfe9661955543ce203c60f9225bbdf33f6bb/libc/unistd/popen.c
	 */
	FILE* popenRead(const char* program, const char* type) {
		volatile internal::pid* cur;
		FILE *iop;
		int pdes[2];
		pid_t pid;
		int result;

		if ((*type != 'r' && *type != 'w') || type[1] != '\0') {
			errno = EINVAL;
			return (NULL);
		}
		cur = new internal::pid{nullptr, nullptr, 0};

		result = pipe(pdes);
		if (result != 0) {
			log_error("pipe has failed. errno is ", errno, "description: ", strerror(errno));
			delete cur;
			return nullptr;
		}
		switch (pid = fork()) {
		case -1:
			/* Error. */
			log_error("fork has failed. errno is ", errno, "description: ", strerror(errno));
			log_error("AFAIK there are either 2 issues: ");
			log_error("1) there is left literally no memory. Consider buying new RAM or creating a swap");
			log_error("2) overcommit is prevented (see https://stackoverflow.com/a/15623171/1887602). Or with root do \" echo 1 > /proc/sys/vm/overcommit_memory\"");
			log_error("3) the child process didn't exit before running out of memory. Happens if you're running a big script taking lots of memory");

			close(pdes[0]);
			close(pdes[1]);
			delete cur;

			return nullptr;
		case 0: {
			/* Child. */
			
			/*
			* We fork()'d, we got our own copy of the list, no
			* contention.
			*/
			for (internal::pid* pcur = internal::pidlist; pcur; pcur = pcur->next) {
				result = close(fileno(pcur->fp));
				if (result != 0) {
					log_error("failed closing a file. errno is ", errno, "description: ", strerror(errno));
				}
			}
			if (*type == 'r') {
				(void) close(pdes[0]);
				if (pdes[1] != STDOUT_FILENO) {
					(void)dup2(pdes[1], STDOUT_FILENO);
					(void)close(pdes[1]);
				}
			} else {
				(void)close(pdes[1]);
				if (pdes[0] != STDIN_FILENO) {
					(void)dup2(pdes[0], STDIN_FILENO);
					(void)close(pdes[0]);
				}
			}
			char* const argp[] = {const_cast<char*>("sh"), const_cast<char*>("-c"), const_cast<char*>(program), nullptr};
			char* const environment[] = { nullptr };
			//execve(_PATH_BSHELL, argp, environ);
			execve("/bin/sh", argp, environment);
			//execl("/bin/sh", "sh", "-c", program, NULL);
			_exit(127);
			/* NOTREACHED */
			}
		}
		/* Parent; assume fdopen can't fail. */
		if (*type == 'r') {
			iop = fdopen(pdes[0], type);
			(void)close(pdes[1]);
		} else {
			iop = fdopen(pdes[1], type);
			(void)close(pdes[0]);
		}
		/* Link into list of file descriptors. */
		cur->fp = iop;
		cur->pid =  pid;
		cur->next = internal::pidlist;
		internal::pidlist = const_cast<internal::pid*>(cur);
		return (iop);
	}

	

	MemoryConsumption getProcessUsedRAM(pid_t processId) {
		std::ifstream f;
		f.open(scout("/proc/", processId, "/status"));
		std::string variableName;
		while (f >> variableName) {
			// https://stackoverflow.com/a/22326766/1887602
			// https://stackoverflow.com/a/64422/1887602
			// I've opened system monitor and I noticed that the process ram shown there is the same of RssAnon
			if (boost::starts_with(variableName, "RssAnon")) {
				std::string variableValue;
				std::string unit;
				f >> variableValue >> unit;
				auto kilobytes = parseFromString<size_t>(variableValue);
				f.close();
				return MemoryConsumption(kilobytes, MemoryConsumptionEnum::KILOBYTE).to(MemoryConsumptionEnum::BYTE);
			}
		}
		f.close();
		throw cpp_utils::exceptions::ImpossibleException{"VmRSS not found in status file!"};
	}

	MemoryConsumption getSystemRAMUsed() {
		std::ifstream f;
		f.open("/proc/meminfo");

		bool totalFound = false;
		bool freeFound = false;
		bool shmemFound = false;
		bool buffersFound = false;
		bool sreclaimableFound = false;
		bool cachedFound = false;
		size_t memtotal;
		size_t memfree;
		size_t membuffers;
		size_t memshmem;
		size_t memsreclaimable;
		size_t memcached;

		std::string variableName;
		while (f >> variableName) {
			if (boost::starts_with(variableName, "MemTotal")) {
				std::string variableValue, unit;
				f >> variableValue >> unit;
				memtotal = parseFromString<size_t>(variableValue);
				totalFound = true;
			}
			if (boost::starts_with(variableName, "MemFree")) {
				std::string variableValue, unit;
				f >> variableValue >> unit;
				memfree = parseFromString<size_t>(variableValue);
				freeFound = true;
			}
			if (boost::starts_with(variableName, "Shmem")) {
				std::string variableValue, unit;
				f >> variableValue >> unit;
				memshmem = parseFromString<size_t>(variableValue);
				shmemFound = true;
			}
			if (boost::starts_with(variableName, "Buffers")) {
				std::string variableValue, unit;
				f >> variableValue >> unit;
				membuffers = parseFromString<size_t>(variableValue);
				buffersFound = true;
			}
			if (boost::starts_with(variableName, "Cached")) {
				std::string variableValue, unit;
				f >> variableValue >> unit;
				memcached = parseFromString<size_t>(variableValue);
				cachedFound = true;
			}
			if (boost::starts_with(variableName, "SReclaimable")) {
				std::string variableValue, unit;
				f >> variableValue >> unit;
				memsreclaimable = parseFromString<size_t>(variableValue);
				sreclaimableFound = true;
			}

			// see "man free"
			if (totalFound && freeFound && shmemFound && buffersFound && sreclaimableFound && cachedFound) {
				size_t memShared = memshmem;
				size_t memUsed = memtotal - memfree - membuffers - memcached;
				f.close();
				return MemoryConsumption(memUsed + memShared, MemoryConsumptionEnum::KILOBYTE).to(MemoryConsumptionEnum::BYTE);
			}
		}
		f.close();
		throw cpp_utils::exceptions::ImpossibleException{"MemTotal or MemFree not found in status file!"};
	}

	pid_t getCurrentPID() {
        return ::getpid();
    }


	std::vector<boost::filesystem::path> getOpenFileDescriptors() {
		DIR *dp;
		std::vector<boost::filesystem::path> result{};

		std::string filename = scout("/proc/", getCurrentPID(), "/fd/");
		dp = opendir(filename.c_str());
		if (dp != NULL) {
			struct dirent *ep;
			while (ep = readdir(dp)) {

				std::string subFileInvolved{filename + ep->d_name};
				if (boost::filesystem::is_symlink(subFileInvolved)) {
					result.push_back(getLinkTargetName(subFileInvolved));
				} else {
					result.push_back(subFileInvolved);
				}
				
			}
			closedir(dp);
		} else {
			throw cpp_utils::exceptions::FileOpeningException{filename};
		}

		return result;
	}

	boost::filesystem::path getLinkTargetName(const boost::filesystem::path& link) {
		char buffer[BUFFER_SIZE];
		debug("reading link ", boost::filesystem::absolute(link.string()).c_str());
		ssize_t bytesWritten = ::readlink(boost::filesystem::absolute(link.string()).c_str(), &buffer[0], BUFFER_SIZE);

		if (bytesWritten < 0) {
			log_error("reason", strerror(errno));
			throw cpp_utils::exceptions::ImpossibleException{"readlink error!"};
		}
		if (bytesWritten >= BUFFER_SIZE) {
			throw cpp_utils::exceptions::ImpossibleException{"buffer completely full!"};
		}
		//append null termination since readLinkDoesn't do it
		buffer[bytesWritten] = '\0';

		return buffer;
	}


	int callExternalProgram(const char* format, ...) {
		char buffer[1000];
		va_list va;
		va_start(va, format);
		vsnprintf(buffer, 1000, format, va);
		va_end(va);

		info("command to execute ", buffer);
		int exitCode = system(buffer);
		if (exitCode != 0) {
			throw exceptions::CommandFailedException{std::string{buffer}, exitCode};
		}
		return exitCode;
	}

	bool isProgramInstalled(const std::string& command) {
		std::string output = callUnsafeExternalProgramAndFetchOutput("which ", command);
		critical("output of which ", command, "is \"", output, "\"");
		return output.size() > 0;
	}

}